Bound: Somatorio de max(0, out - in) pra cada vertice, pro DAG com todos os caminhos isso é exato, se não é só um bound

Bound: Euler com mais coisa (max((out + in) / 2) pra quando soma de max(0, out - in) de uma componente é 0?)

Talvez pensar na variante do problema em que nem sempre tem solucao

Enhance the packing bounds

Possibly use some kind of hot starting because we do DFS
    This seems very doable

Interleaved DFS
Randomization, Restart strategies, start the interleaf when finding a tie in the greatest degree
BFS with diving (temos restricoes de memoria, talvez contornar se voltassemos poucas vezes)
Interleaved seems more doable tho

Try to think of some kind of Arc Consistency or Nogood recording
Primeiro modelar nosso problema como um CSP (busca binaria ?) (relacao com o upper bound ?)
    Cada caminho é uma variavel binaria
    Restricoes: Soma das variaveis binarias <= UB
    Soma dos caminhos que passam por cada aresta >= 1
Ver se conseguimos calcular consistencia de arco para um unico constraint (besta)
Forward Checking: Uma aresta só tem um unico caminho nao definido (Unit Edge Rule) Ja fazemos

Que tal fazer branching sobre o caminho que esta na aresta de menor grau ?
Ver se conseguimos definir o que torna uma solucao inconsistente de forma efetiva (nogood, n tentei pensar ainda)

Busca heuristica no comeco do B&B para ja comecar com uma solução incumbente decente (só no começo)

Melhorar o Sum of Degrees Bound usando um preprocessamento n^2 (Tipo um inclusao exclusao incompleto) ou ate n^3
    Escolhi os caminhos A1, A2, A3, A4, A5, posso subtrair as arestas que estao nos pares (A1, A2), (A2, A3), (A3, A4), (A4, A5)
    Com a garantia de contar cada aresta pelo menos uma vez
    Isso da ruim pois pode ser que Ax seja maior que A2 - (A1, A2) por exemplo
    N rola bruh

Pensar no solver exatos para classes de grafos podendo repetir aresta

Max Weighted Cut pra DAG

Independent strategies

Diferentes Branchings

DSU
    Binario, escolher um par que tem uma quantidade parecida de vertices que soh cobrem um e vertices que cobrem os dois
    Precalcular isso soh no comeco
    Talvez usar esse branching apenas no comeco (tipo fazer esse branching c vezes) pq dps de um tempo deve ficar desequilibrado
    Ou fazer esse branching enquanto continuar relativamente equilibrado e dps passar para uma outra estrategia
    Nao precisa de DSU, soh vamos fixar alguns vertices fora da resposta
    Precisamos codar a versao exata tho

Wide (escolher qual caminho passa por uma aresta) (Problema: Overcounting) (prohibited)
    Codamos e o prohibited conserta o problema de Overcounting
    Implementamos um preprocessamento para a ordem dos vertices
    Em instancias com muita aresta e pouco vertice ele apanha bastante

Costly Inclusion

Pensar nas alteracoes para o solver exato

Lower Bounds - Normal
Upper Bound - 
Unit Edge Rule - Depende se vamos permitir que o problema nao tenha solucao
Edge Domination Rule - Nao podemos pegar os vertices fora da intersecao (depende se vamos permitir...)
Vertex Domination Rule - Deixa de fazer sentido

Operacao de colocar um vertice na resposta agora eh bem custosa (tem que bloquear todos os vertices que tem intersecao com ele)
Branching depende muito do tipo da instancia né (caminhos longos ou nao) (talvez trabalhar no k-PSEC com k pequeno)
Acho que temos que definir uma classe especifica de instancias para trabalhar, pq tudo fica mt no depende

https://garethrees.org/2007/06/10/zendoku-generation/#section-4.2
Qd possivel, fazer o branching em cima de pontes
Se nao, fazer o branching em cima de vertices de grau baixo para criar pontes (como saber grau de vertice? soh manter um vetor global)
Tentar fazer um divide and conquer e achar um corte de tamanho pequeno que divide o grafo mais ou menos pela metade

Erdos renyi
Preferential Attachment

Particao
Nao direcionado
Nao gerar tudo inviavel
Nao gerar muito facil tbm
Criar uma solucao viavel e dai gerar os caminhos
Achar se o problema eh viavel eh np dificil ? (Prove)
Path partition

Graph decomposition is NPC - a complete proof of Holyer's conjecture
The NP-Completeness of Some Edge-Partition Problems - nao consegui acessar

Instancias:
3DMR
    Bloco de tamanho 7
    Juntar blocos separados
    Juntar de 3 em 3 (random ou nao) OK
Transformar instancias do 3dmr em PCEC OK
Erdos Renyi (esparsos e densos) OK 
Preferential Attachment OK
Redes reais (Pegar dps que eu tiver uma ideia do tamanho)
Arvore random e dai adicionar arestas random OK

Caminhos:
Comecar em uma aresta e ir expandindo aleatorio para algum lado OK
Pegar todos os caminhos de tamanho 3 OK
Pegar varios caminhos pequenos e varios caminhos grandes
Definir uma probabilidade do caminho terminar (ir expandindo ate nao dar mais ou ate bater na probabilidade)

Existe uma instancia dificil do 3DMR ?
    Fazer 000, 111, 222... e depois juntar em pares para que tenha soh uma resposta possivel
    0 e 1 aparecem sempre em pares e o 2 sempre sozinho
    Com isso conseguimos fazer instancias dificeis grandes com n multiplo de 3
    Isso garante

